Homework 07
===========
Activity 1 dd.py
1.  In parsing the command line options I first tried to use getopts but then realized that the dd command does not take flags, rather it takes actual string in.  Since I couldn't use getopts I used a for loop that looped through sys.argv[1:].  The loop uses an if statment to check the first letter of each option and then if it finds a match it splits that string at the '=' and sets the appropriote variable to whatever the user inputted.  For example if the command run was:
    $ dd  if=file.txt
    FILE would now equal file.txt because the string was split at the equals sign.  

2. I opened the input and output files with the functions open_fd.  Open_fd uses os.open().  Since stdin could be an option I had to add an if statement because it is impossible to open standard in.  If there was no file specified the file descriptor was set to 0.  I used the same sort of logic for the output file since it is impossible to open standard out.  If there was no output file specified then the fo variable was set to 1.  For output I used modes WRONLY and CREAT while for input I used RDONLY.  

3.  At first the seek and skip arguments seemed very challenging however I then just realized that os.lseek can be used.  os.lseek() sets the current position of the file descriptor to the given position.  Since skip manipulates the input I used SKIP*BYTES.  This is called in the os.lseek function when setting the file descriptor to either 0 (stdin) or the specified file.  Since seek manipulates the output I used SEEK*BYTES in the os.lseek function when setting the file descriptor for output to either 1 (stdin) or the specified file.  

4. I used count and bs in the while loop used to write to the output file.  The variable data is set to read the given amount of bytes (or default amount) from the file descriptor.  The while loop goes until data ends (the end of file is reached).  This loop also depends on count.  The loop will go until the end of file is reached or if the specified number of byte blocks (i.e. count).  Each time a certain amount of bits is written the counter increases.  

Activity 2 find.py
1.  When parsing the command line I first made a list of all the options given and split them with an '=' is necessary.  Then, with this list I used a for loop to go through and match the options and set appropriote variables.  If the certain option had an argument that went with it I saved that variable using args[count +1] becuase it would be the next item in the list due to the splitting I did in the beggining.  If the option had an argument I incremented counter by 2 to skip the next item in the list but if there were no arguments passed with the option I incremented the counter by 1.  

2.  I walked the directory tree with a for loop that saved three variables: root, dirs, and files.  I then used the command os.walk(directory, followlinks=True).  I have a for loop within the for loop to join the root and name of the file or directory to create the full path, this is saved in the variable path (path = os.path.join(root,name).   

3.  Determining whether or not to print a filesystems object path is the most complicated part of the script.  I created a function called include which returns true if the file should be printed.  I put include in an if statement and if it returns True then the path will be printed.  The first thing the include function does is try to run os.stat on the path.  If it can do this then it means the program has permission to access the file and if not then the broken variable is set to false and os.lstat is run instead.  Inside the include function I check for all the specified fields.  To check if a file is of a certain type I used os.path.isfile or os.path.isdir.  If the specified type and the current file being looked at do not match then include returns false and the path is not printed.  The function checks for executablility, readability and writability with os.access.  To check for emptyness I used multiple if statemnts using os.isfile / isdir,  os.stat.st_size, and os.path.isdir.  A try statement is used to see if the directory is empty.  I used fnmatch to match the names and path, re.search to match the regular expression, and st_mode to match the file permissions.  To see if a file has been modified before the given file (newer) I use .st_mtime.  To check for uid and gid I use .st_uid / st_gid.  All of the exact commads can be seen in the program itself in the include function.  If the function catches none of these things then it returns True (also returns True is the default values are the same as the specified values aka no options passed).  The program passes the find test script given and gives the correct output when run on my owwn directory as well.  

4. When I run strace on ./find.py and find -L both have a very long output.  I then piped the strace command to wc -l and got 20732 for both commands.  This leads me to believe that find is getting the file information in a similar way I am, by trying os.stat for every file in the path before trying to match it with any of the options given.  I do this in the first few lines of my include function which is called for every file that could possibly be printed.  I think that the traditional find does the same because the outputs of strace were very similar.  
