Homework 08
===========
Activity 1- timeout.py

1. The role of the child process (PID = 0) is to exec the command given.  The child process does this through the command os.execlp.  A try and except block is used to supress the error if the exec is failed.  The role of the parent process is to enable the alarm, kill the child process if necessary, then wait for the child process to finish.  The parent process enables the alarm using the command signal.signal(signal.SIGALRM, sig_handler).  In the sig_handler function the os.kill command is used to kill the child process and the os.wait command is used to wait for the child process to be done.  

2.  The timeout mechanism works through the sig_handler function and the signal.alarm function.  When the parent process is running it calls the sig_handler function with the signal type as SIGALRM.  Then, the alarm is set to the specified amount of seconds.  If the alarm goes off before the program exits this means that the child process did not finish before the allotted time.  When the alarm goes off the sig_handler function is triggered and calls os.kill() to kill the child process and then os.wait to ensure no "zombies" are made.  

3.  The test script uses a series of if statements to verify the correctness of the timeout.py script.  First the test script tests if the file timeout.py is an executable, if this returns false then the script exits with the message at it failed because the file is not an executable.  The script verfies the shebang using head-n 1 | grep -o 'python2.7.'  A similar process is used to verify the correctness of the usage function.  If either of these do not match then the script fails and outputs an appropriote error message.  The script uses for loops to test booth expected failure and expected output. The script runs either the command:
    ./timeout.py -t 1 sleep $N || echo Failure >results1.txt
    (where N is 2 3 4 5)
or the command:
    ./timeout.py -t 5 sleep $N && echo sucess > results1.txt
    (where N is 1 2 3 4)
If the output written to the results1.txt file is not the same as a text file that just reads 'Success" or 'Failure' then the test script wil exit and display an approproite error message.  The script also makes sure to remove the results file each time the command is run.  The verbose output is verified by checking the line count of the output and if it is within a reasonable number then the test passes through to the final echo statement which prints that the timeout.py program has passed the test.  

4.  I created a shell script that has a for loop and runs the command ./timeout.py -t 2 sleep 2 && echo Success and the command ./timeout.py -t 2 sleep 2|| echo Failure 300 times.  Each time Failure was printed.  This because the parent process ran first everytime so the alarm was set before the child could exec the command making the alarm go off just before the sleep command finished.  This being said it is still reasonable to expect the script to sometimes print Success because while uncommon, it is still possible for the child process to run first which would mean the sleep command would finish just before the alarm would go off.  

Activity 2: rorschach.py

1. I scanned the files in each directory similarly to the way I scanned them in find.py.  I used a for loop to go through the list of directories (to ensure each one would be iterated through if given more than one directory to watch).  I used os.walk to create a list of paths to each file in the directory given using a for loop within the for loop that is iterating through the directories list.  For each path created by os.walk, the path itself was saved into a list (results) and the modification time was also saved into a list (mtime).  I obtained the modification time for each file by using the command os.stat(path.st_mtime.  

2.  I loaded the rules using the yaml.load() function.  To load the pattern I just used the command PATTER=doc['pattern'].  I did this as well for the action command but then changed the word within the {} to a number so I could use the str.format() command when calling the action on a specific path.  I did this using a for loop to iterate through the action list.  I used re.search and glob.glob to check the files to see if they matched the pattern.  Since re.search and glob.glob can sometimes fail I used try/except block within the my check_directory function to search for matches.  

3.  I created a dictionary of paths to files and modification times by joining the two lists mentioned above (results and mtime).  I did this using the zip command.  Then I iterated through this dictionary and used the check_directory function and the check_status function to see if the action should be performed on the specific file.  The check_directory function uses re.search or glob.glob to find a match for the file (as mentioned in number 2).  The check_status function compares TIME (time.time()) to the corresponding mtime value for the path under test.  An if statement says that if TIME < mtime + the number of second in between command calls, return False.  This means that since the last time the program was called, the file was not modified and the action should not be executed.  

4. I executed the given action if and only if both check_directory and check_status returned true.  If so, then the path is sent to the function execute_action.  This function forks the process, execs the command given by the commands variable (created by editing the action recieve from the yml file).  A try/except block must be used in case the fork or exec fails.  Then, the parent process waits for the child proccess to finish. 

5.  Busy-waiting means that the program wastes time running through a loop checking each iteration of that loop.  In context of rorschach.py busy waiting would be the time it talks the program to walk the directory and check each path in the directory to see if it matches the pattern.  This could be an issue since the time saved at the beggining of the program does not account for the delays of the loops, thus an inaccurate result could occur when coparing the time and the mtime of the file.  One way to fix this could be to change where you call time.time() to the exact time of when you are checking the mtime rather than when the program is first run or time the amount of time the program wastes iterating through the loops and checking each path and factor this into the time varibale when checking mtime.  Cache invalidation is when entires in a cache, or in rorschach.py: a dictionary, are removed.  In the program now the dictionary storing results and mtime is never deleted, rather it just keeps growing. One way to fix this would be to delete or clear the ditionary at the end of each while iteration, like the results and mtime lists are cleared.  Another way descirbed as "purging" would be to remove the entry in each dictionary as soon as you check if it fits the pattern and the mtime is appropriote.  This could be done in the check_dictionary or check_status functions.  
